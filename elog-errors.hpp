// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace Error
{
    struct Error;
} // namespace Error
} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace Error
{
    struct AssociationError;
} // namespace Error
} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace Error
{
    struct InventoryError;
} // namespace Error
} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace _InventoryError
{

struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _InventoryError

struct InventoryError : public sdbusplus::exception_t
{
    static constexpr auto errName = "xyz.openbmc_project.Led.Fru.Monitor.InventoryError";
    static constexpr auto errDesc = "Invalid Inventory Path";
    static constexpr auto L = level::INFO;
    using PATH = _InventoryError::PATH;
    using metadata_types = std::tuple<PATH>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Led::Fru::Monitor::Error::InventoryError>
{
    using type = xyz::openbmc_project::Led::Fru::Monitor::InventoryError;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace _AssociationError
{

struct ELOG_ENTRY_PATH
{
    static constexpr auto str = "ELOG_ENTRY_PATH=%s";
    static constexpr auto str_short = "ELOG_ENTRY_PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr ELOG_ENTRY_PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _AssociationError

struct AssociationError : public sdbusplus::exception_t
{
    static constexpr auto errName = "xyz.openbmc_project.Led.Fru.Monitor.AssociationError";
    static constexpr auto errDesc = "Error in retrieving the associations";
    static constexpr auto L = level::INFO;
    using ELOG_ENTRY_PATH = _AssociationError::ELOG_ENTRY_PATH;
    using metadata_types = std::tuple<ELOG_ENTRY_PATH>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Led::Fru::Monitor::Error::AssociationError>
{
    using type = xyz::openbmc_project::Led::Fru::Monitor::AssociationError;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace _Error
{

struct DETAILS
{
    static constexpr auto str = "DETAILS=%s";
    static constexpr auto str_short = "DETAILS";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr DETAILS(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};
struct OBJECT_MANAGER_INTERFACE
{
    static constexpr auto str = "OBJECT_MANAGER_INTERFACE=%s";
    static constexpr auto str_short = "OBJECT_MANAGER_INTERFACE";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr OBJECT_MANAGER_INTERFACE(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Error

struct Error : public sdbusplus::exception_t
{
    static constexpr auto errName = "xyz.openbmc_project.Led.Mapper.Error";
    static constexpr auto errDesc = "A failure in Object Mapper Operation";
    static constexpr auto L = level::INFO;
    using DETAILS = _Error::DETAILS;
    using PATH = _Error::PATH;
    using OBJECT_MANAGER_INTERFACE = _Error::OBJECT_MANAGER_INTERFACE;
    using metadata_types = std::tuple<DETAILS, PATH, OBJECT_MANAGER_INTERFACE>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Led::Mapper::Error::Error>
{
    using type = xyz::openbmc_project::Led::Mapper::Error;
};

}


} // namespace logging

} // namespace phosphor
